package com.oblivm.backend.generated.stack;

#define PUSH 0
#define POP 1

typedef ints_ = secure int;
typedef intp_ = public int;
typedef intr_ = rnd;
typedef NonRecursiveORAM@m<T> = native CircuitOram(m, sizeof(T));

intr_@m RND(intp_32 m) = native intLib.randBools;

phantom StackNode@m<T> NonRecursiveORAM@m<T>.readAndRemove(int@m id, rnd@m pos) = native conditionalReadAndRemove;
phantom void NonRecursiveORAM@m<T>.add(int@m id, rnd@m pos, StackNode@m< T > node) = native conditionalPutBack;
 
struct BoolArray{ints_32 data;};
 
struct StackNode@m<T> {
   intr_@m next;
   T data;
};
 
struct Stack@m<T> {
   intr_@m root;
   ints_@m size;
   NonRecursiveORAM@(1 << m)< StackNode@m<T> > oram;
};

phantom void Stack@m<T>.push(T operand) {
      StackNode@m<T> node = 
         StackNode@m{T} ( next = this.root,
               data = operand);
      this.root = RND(m);
      this.size  = this.size + 1;
      this.oram.add(this.size, this.root, node);
}

phantom T Stack@m<T>.pop() {
   	T ret;
	StackNode@m< T > r = this.oram.readAndRemove(this.size, this.root);
	this.root = r.next;
	this.size = this.size - 1;
	ret = r.data;
   	return ret;
}

T Stack@m<T>.op(int operand, T value) {
	T ret;
	if (operand == 0) {
		this.push(value);
	} else {
		ret = this.pop();
	}
	return ret;
}

int main@n(int[n] x, int[n] y) {
	Stack@10<int> stack;
	for(public int i=0; i<n; i=i+1) {
		stack.op(y[i], x[i]);
	}
	return stack.pop();
}
